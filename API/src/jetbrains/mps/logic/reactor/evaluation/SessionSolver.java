package jetbrains.mps.logic.reactor.evaluation;

/*Generated by MPS */

import jetbrains.mps.logic.reactor.program.PredicateSymbol;
import jetbrains.mps.logic.reactor.program.Predicate;
import java.util.Arrays;
import jetbrains.mps.logic.reactor.program.Symbol;
import java.util.Map;
import java.util.List;
import java.util.HashMap;

/**
 * Is used to provide an interface for handlers and solvers working together in a single session.
 */
public abstract class SessionSolver implements Instructible, Queryable {

  public void init(PredicateSymbol... predicateSymbols) {
    registerSymbols(predicateSymbols);
  }

  public void init(EvaluationTrace evaluationTrace, PredicateSymbol... predicateSymbols) {
    tracer = evaluationTrace;
    init(predicateSymbols);
  }

  @Override
  public boolean ask(PredicateInvocation invocation) {
    boolean result = solver(invocation.predicate().symbol()).ask(invocation);
    tracer.ask(result, invocation);
    return result;
  }

  /**
   * To be used internally. For testing pupposes. 
   */
  public boolean ask(PredicateSymbol predicateSymbol, Object... args) {
    Solver solver = solver(predicateSymbol);
    Predicate predicate = solver.predicate(predicateSymbol, args);
    SessionSolver.Invocation invocation = new SessionSolver.Invocation(predicate, Arrays.asList(args));

    return solver(predicateSymbol).ask(invocation);
  }

  @Override
  public void tell(PredicateInvocation invocation) {
    tracer.tell(invocation);
    handler(invocation.predicate().symbol()).tell(invocation);
  }

  /**
   * To be used internally. For testing pupposes. 
   */
  public void tell(Symbol symbol, Object... args) {
    Solver solver = solver((PredicateSymbol) symbol);
    Predicate predicate = solver.predicate((PredicateSymbol) symbol, args);
    SessionSolver.Invocation invocation = new SessionSolver.Invocation(predicate, Arrays.asList(args));

    solver.tell(invocation);
  }

  @Deprecated
  public abstract Class<? extends Queryable> solverClass(PredicateSymbol predicateSymbol);

  protected abstract void registerSymbol(PredicateSymbol predicateSymbol, EvaluationTrace computingTracer);

  protected void registerSolver(PredicateSymbol constraint, Solver solver) {
    solvers.put(constraint, solver);
  }

  private Instructible handler(Symbol symbol) {
    return solver((PredicateSymbol) symbol);
  }

  private void registerSymbols(PredicateSymbol... predicateSymbols) {
    for (PredicateSymbol symbol : predicateSymbols) {
      registerSymbol(symbol, tracer);
    }
  }

  private Solver solver(PredicateSymbol predicateSymbol) {
    if (!(solvers.containsKey(predicateSymbol))) {
      throw new IllegalStateException("no handler: " + predicateSymbol);
    }
    return solvers.get(predicateSymbol);
  }

  private static class Invocation implements PredicateInvocation {

    public Invocation(Predicate predicate, List<?> args) {
      this.predicate = predicate;
      this.args = args;
    }

    public Predicate predicate() {
      return predicate;
    }

    public List<?> arguments() {
      return args;
    }

    private Predicate predicate;
    private List<?> args;
  }

  private Map<PredicateSymbol, Solver> solvers = new HashMap<PredicateSymbol, Solver>();
  private EvaluationTrace tracer = EvaluationTrace.NULL;

}
