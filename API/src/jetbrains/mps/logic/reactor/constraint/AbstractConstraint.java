package jetbrains.mps.logic.reactor.constraint;

/*Generated by MPS */


/**
 * Abstract superclass for use in implementations of Constraint and AutoConstraint.
 */
public abstract class AbstractConstraint implements ComputingItem {

  public AbstractConstraint(String symbol, int arity) {
    this.symbol = symbol;
    this.arity = arity;
  }

  public String name() {
    return symbol;
  }

  public String symbol() {
    return symbol;
  }

  public int arity() {
    return arity;
  }

  public Instructible handler(ComputingSession session) {
    return session.handler(asConstraint());
  }

  public Queryable solver(ComputingSession session) {
    return session.solver(asAutoConstraint());
  }

  public abstract Class<? extends Queryable> solverClass();

  public Class<? extends Instructible> handlerClass() {
    return solverClass();
  }

  @Override
  public String toString() {
    return symbol;
  }

  public Constraint asConstraint() {
    return (Constraint) this;
  }

  public BuiltinConstraint asAutoConstraint() {
    return (BuiltinConstraint) this;
  }

  protected void registerHandler(ComputingSession session, Instructible instructible) {
    session.registerHandler(asConstraint(), instructible);
  }

  protected void registerSolver(ComputingSession session, Queryable queryable) {
    session.registerSolver(asAutoConstraint(), queryable);
    session.registerHandler(asConstraint(), queryable);
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || this.getClass() != o.getClass()) {
      return false;
    }

    AbstractConstraint that = (AbstractConstraint) o;
    if ((symbol != null ? !(((Object) symbol).equals(that.symbol)) : that.symbol != null)) {
      return false;
    }

    return true;
  }

  @Override
  public int hashCode() {
    int result = 17;
    result = 31 * result + ((symbol != null ? String.valueOf(symbol).hashCode() : 37));
    return result;
  }

  private String symbol;
  private int arity;
}
