package jetbrains.mps.logic.reactor.constraint;

/*Generated by MPS */

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

/**
 * Computing session is used to provide an interface for handlers and solvers working together in a single session.
 */
public class ComputingSession {

  public static ComputingSession.Builder with(ComputingItem... cst) {
    return new ComputingSession.Builder(cst);
  }

  private ComputingSession(ComputingTracer tracer) {
    this.tracer = tracer;
  }

  public static class Builder {

    private Builder(ComputingItem... item) {
      items.addAll(Arrays.asList(item));
    }

    public ComputingSession.Builder withTracer(ComputingTracer tracer) {
      this.tracer = tracer;
      return this;
    }

    public ComputingSession newSession() {
      ComputingSession session = new ComputingSession(tracer);
      for (ComputingItem ci : items) {
        ci.init(session, tracer);
      }
      return session;
    }

    private List<ComputingItem> items = new ArrayList<ComputingItem>();
    private ComputingTracer tracer;
  }


  public boolean ask(AutoConstraint autoConstraint, Object... arg) {
    Queryable solver = solver(autoConstraint);
    if (solver == null) {
      throw new IllegalStateException("no solver for '" + autoConstraint.symbol() + "'");
    }

    return solver.ask(autoConstraint, arg);
  }

  public void tell(Constraint constraint, Object... arg) {
    Instructible handler = handler(constraint);
    if (handler == null) {
      throw new IllegalStateException("no handler for '" + constraint.name() + "'");
    }

    handler.tell(constraint, arg);
  }

  public Constraint lookupConstraint(Class<?> clazz) {
    for (Map.Entry<Constraint, Instructible> e : handlers.entrySet()) {
      if (clazz.isAssignableFrom(e.getKey().handlerClass())) {
        return e.getKey();
      }
    }
    return null;
  }

  public AutoConstraint lookupAutoConstraint(Class<?> clazz) {
    for (Map.Entry<AutoConstraint, Queryable> e : solvers.entrySet()) {
      if (clazz.isAssignableFrom(e.getKey().solverClass())) {
        return e.getKey();
      }
    }
    return null;
  }

  protected Instructible handler(Constraint constraint) {
    if (!(handlers.containsKey(constraint))) {
      throw new IllegalStateException("no handler: " + constraint);
    }
    return handlers.get(constraint);
  }

  protected Queryable solver(AutoConstraint constraint) {
    if (!(solvers.containsKey(constraint))) {
      throw new IllegalStateException("no handler: " + constraint);
    }
    return solvers.get(constraint);
  }

  protected void registerHandler(Constraint constraint, Instructible instructible) {
    handlers.put(constraint, instructible);
  }

  protected void registerSolver(AutoConstraint constraint, Queryable queryable) {
    solvers.put(constraint, queryable);
  }

  private Map<Constraint, Instructible> handlers = new HashMap<Constraint, Instructible>();

  private Map<AutoConstraint, Queryable> solvers = new HashMap<AutoConstraint, Queryable>();

  private final ComputingTracer tracer;
}
